var _ = require('lodash');
var Promise = require('bluebird');
//var sqlite = require('sqlite-sync');
//var DB_FILENAME = 'barker_database.db';
//var db = {
//  cursor: sqlite.connect(DB_FILENAME),
//};
var sqlite = require('sqlite');
const dbPromise = sqlite.open(':memory:', { Promise });
//var db = new sqlite3.Database(':memory:');
exports.dbPromise = dbPromise;

var table_defs = [
    {
        table_name:  'users',
        obj_type: 'user',
		primary_key: 'user_id',
        schema: {
            columns: [
                {
                    name: 'user_id',
                    type: 'text primary key',
                    desc: 'primary key',
                },
                {
                    name: 'name',
                    type: 'text',
                    desc: 'the user specified name of the user',
                },
                {
                    name: 'email',
                    type: 'text',
                    desc: 'the user specified email of the user',
                },
                {
                    name: 'hidden',
                    type: 'integer default 0',
                    desc: 'whether the account is active',
                },
            ],
        },
    },
    {
        table_name:  'pets',
        obj_type: 'pet',
		primary_key: 'pet_id',
        schema: {
            columns: [
                {
                    name: 'pet_id',
                    type: 'integer primary key autoincrement',
                    desc: 'primary key',
                },
                {
                    name: 'user_id',
                    type: 'text',
                    desc: 'the foreign key to the user object',
                },
                {
                    name: 'name',
                    type: 'text',
                    desc: 'the user specified name of the pet displayed in the app',
                },
                {
                    name: 'image_url',
                    type: 'text',
                    desc: 'the full url of the image file in the bucket',
                },
                {
                    name: 'hidden',
                    type: 'integer default 0',
                    desc: 'set to 1 if the user has "deleted" this object',
                },
            ],
        },
    },
    {
        table_name:  'raws',
        obj_type: 'raw',
		primary_key: 'uuid',
        schema: {
            columns: [
                {
                    name: 'uuid',
                    type: 'text',
                    desc: 'uuid is both the primary key for the object in the database, as well as the filename in the bucket',
                },
                {
                    name: 'pet_fk',
                    type: 'text',
                    desc: 'the foreign key to the pet object the raw audio was recorded from',
                },
                {
                    name: 'user_id',
                    type: 'text',
                    desc: 'the foreign key to the user object',
                },
                {
                    name: 'name',
                    type: 'text',
                    desc: 'the user specified name displayed in the app',
                },
                {
                    name: 'bucket_url',
                    type: 'text',
                    desc: 'the full url of the audio file in the bucket',
                },
                {
                    name: 'bucket_fp',
                    type: 'text',
                    desc: 'the relative path (to bucket root) of the audio file in the bucket',
                },
                {
                    name: 'stream_url',
                    type: 'text',
                    desc: 'the generated stream url (this is generated by the backend as needed)',
                },
                {
                    name: 'hidden',
                    type: 'integer default 0',
                    desc: 'set to 1 if the user has "deleted" this object',
                },
            ],
        },
    },
    {
        table_name:  'crops',
        obj_type: 'crop',
		primary_key: 'uuid',
        schema: {
            columns: [
                {
                    name: 'uuid',
                    type: 'text',
                    desc: 'uuid is both the primary key for the object in the database, as well as the filename in the bucket',
                },
                {
                    name: 'raw_fk',
                    type: 'text',
                    desc: 'the foreign key to the raw object the crop was generated from',
                },
                {
                    name: 'user_id',
                    type: 'text',
                    desc: 'the foreign key to the user object',
                },
                {
                    name: 'name',
                    type: 'text',
                    desc: 'the user specified name displayed in the app',
                },
                {
                    name: 'bucket_url',
                    type: 'text',
                    desc: 'the full url of the audio file in the bucket',
                },
                {
                    name: 'bucket_fp',
                    type: 'text',
                    desc: 'the relative path (to bucket root) of the audio file in the bucket',
                },
                {
                    name: 'stream_url',
                    type: 'text',
                    desc: 'the generated stream url (this is generated by the backend as needed)',
                },
                {
                    name: 'hidden',
                    type: 'integer default 0',
                    desc: 'set to 1 if the user has "deleted" this object',
                },
            ],
        },
    },
    {
        table_name:  'sequences',
        obj_type: 'sequence',
		primary_key: 'uuid',
        schema: {
            columns: [
                {
                    name: 'uuid',
                    type: 'text',
                    desc: 'uuid is both the primary key for the object in the database, as well as the filename in the bucket',
                },
                {
                    name: 'crop_fk',
                    type: 'text',
                    desc: 'the foreign key to the crop object the sequence was generated from',
                },
                {
                    name: 'user_id',
                    type: 'text',
                    desc: 'the foreign key to the user object',
                },
                {
                    name: 'name',
                    type: 'text',
                    desc: 'the user specified name displayed in the app',
                },
                {
                    name: 'bucket_url',
                    type: 'text',
                    desc: 'the full url of the audio file in the bucket',
                },
                {
                    name: 'bucket_fp',
                    type: 'text',
                    desc: 'the relative path (to bucket root) of the audio file in the bucket',
                },
                {
                    name: 'stream_url',
                    type: 'text',
                    desc: 'the generated stream url (this is generated by the backend as needed)',
                },
                {
                    name: 'hidden',
                    type: 'integer default 0',
                    desc: 'set to 1 if the user has "deleted" this object',
                },
            ],
        },
    },
];
exports.table_defs = table_defs;


async function initialize_db (table_defs) {
	const db = await dbPromise;
	var queries = [];
    _.each(table_defs, (def) => {
        var sql = `CREATE TABLE ${def.table_name} (\n`;
        var col_sql = _.map(_.initial(def.schema.columns), (column) => {
            return `    ${column.name} ${_.upperCase(column.type)},`;   
        });
        var last_column = _.last(def.schema.columns);
        col_sql.push(`    ${last_column.name} ${_.upperCase(last_column.type)}`);
        sql += _.join(col_sql, '\n')
        sql += '\n);';
		queries.push(db.run(sql));
    })
	await Promise.all(queries);
};
exports.initialize_db = initialize_db;


function obj_to_sql (obj) {
    var keys = _.keys(obj);

    var cols = '(\n';
    cols += _.join(_.map(_.initial(keys), (key) => {
        return `    ${key}, \n`;
    }), '');
    cols += `    ${_.last(keys)}\n)`;

    var placeholders = '(\n';
    placeholders += _.join(_.map(_.initial(keys), (key) => {
        return `    $${key}, \n`;
    }), '');
    placeholders += `    $${_.last(keys)}\n)`;

    return {
        columns: cols,
        placeholders: placeholders,
    };
}


function prefix_obj (obj) {
	return _.fromPairs(_.map(_.toPairs(obj), (pair) => {
		return ['$' + pair[0], pair[1]];
	}));
}


function obj_rest_api (def, db) {
    // generate rest endpoints for an object
	// TODO make sure primary keys are immutable
	// TODO error response
    return {
        get_all: {
			request_method: 'get',
            endpoint: `/all/${def.obj_type}/:user_id`,
            handler: async (req, res) => {
                var sql = `SELECT * from ${def.table_name}\n`;
                sql += `    where user_id = "${req.params.user_id}";`;
				var rows = await db.all(sql);
				return res.json(rows);
            },
        },
        get: {
			request_method: 'get',
            endpoint: `/${def.obj_type}/:primary_key`,
            handler: async (req, res) => {
                var sql = `SELECT * from ${def.table_name}\n`;
                sql += `    where ${def.primary_key} = "${req.params.primary_key}";`;
                //console.log(sql);
				return res.json(await db.get(sql));
				//return res.json(rows);
            },
        },
        post: {
			request_method: 'post',
            endpoint: `/${def.obj_type}`,
            handler: async (req, res) => {
                var sql_obj = obj_to_sql(req.body);
                var sql = `INSERT INTO ${def.table_name} ${sql_obj.columns} VALUES ${sql_obj.placeholders};`
                //console.log(sql);
				//console.log(prefix_obj(req.body));
				return res.json({
					last_id: await db.run(sql, prefix_obj(req.body)).lastID,
				});
            },
        },
        put: {
			request_method: 'put',
            endpoint: `/${def.obj_type}`,
            handler:  async (req, res) => {
                var columns = _.keys(req.body);
                var sql = `UPDATE ${def.table_name} SET\n`
                sql += _.join(_.map(_.initial(columns), (column) => {
                    return `    ${column} = $${column},\n`;
                }), '');
                sql += `    ${_.last(columns)} = $${_.last(columns)}\n`;
                //${sql_obj.columns} VALUES ${sql_obj.placeholders};`
                sql += `WHERE ${def.primary_key} = "${req.body[def.primary_key]}";`
				return res.json({
					last_id: await db.run(sql, prefix_obj(req.body)).lastID,
				});
            },
        },
        delete: {
			request_method: 'delete',
            endpoint: `/${def.obj_type}/:primary_key`,
            handler:  async (req, res) => {
                var sql = `UPDATE ${def.table_name}\n`;
                sql += `    set hidden = 1 where ${def.primary_key} = "${req.params.primary_key}";`;
                //console.log(sql);
				return res.json({
					last_id: await db.run(sql).lastID,
				});
            },
        },
    };
}
exports.obj_rest_api = obj_rest_api;


//(async () => {
//	await initialize_db(table_defs);
//	const db = await dbPromise;
//	var api = obj_rest_api(table_defs[0], db);
//	await api.post.handler({
//		body: {
//			user_id: 'some-user-id',
//			name: 'patrick',
//			email: 'pat.w.brooks@gmail.com',
//		},
//	});
//	var rows = await api.get.handler({
//		params: {
//			primary_key: 'some-user-id',
//		},
//	});
//	await api.put.handler({
//		body: {
//			user_id: 'some-user-id',
//			name: 'fart',
//		},
//	});
//	var rows = await api.get.handler({
//		params: {
//			primary_key: 'some-user-id',
//		},
//	});
//	await api.delete.handler({
//		params: {
//			primary_key: 'some-user-id',
//		},
//	});
//	var rows = await api.get.handler({
//		params: {
//			primary_key: 'some-user-id',
//		},
//	});
//	var pet_api = obj_rest_api(table_defs[1], db);
//	var rowid = await pet_api.post.handler({
//		body: {
//			user_fk: 'some-user-id',				
//			name: 'spot',
//		},
//	});
//	var rowid = await pet_api.post.handler({
//		body: {
//			user_fk: 'some-user-id',				
//			name: 'fido',
//		},
//	});
//	var rows = await pet_api.get_all.handler({
//		params: {
//			user_id: 'some-user-id',
//		},
//	});
//})();





//// create one
//app.post('/obj-type', (req, res) => {
//  return res.send('Received a POST HTTP method');
//});
//// read one
//app.get('/obj-type/:uuid', (req, res) => {
//  return res.send('Received a GET HTTP method');
//});
//// update one
//app.put('/obj-type/:uuid', (req, res) => {
//  return res.send('Received a PUT HTTP method');
//});
//// delete one
//app.delete('/obj-type/:uuid', (req, res) => {
//  return res.send('Received a DELETE HTTP method');
//});
//
//// read all
//app.get('/obj-type', (req, res) => {
//  return res.send('Received a GET HTTP method');
//});
