# Models

## models.json
this is a json file that describes the attributes (columns)
of each "object", as well as their visibility via the REST api.
each entry has a number of attributes:
- `table_name`: this is what the table is actually named in the sqlite db
- `obj_type`: this is included in REST responses so the client can introspect objects simply
- `primary_key`: this indicates which column operates (formally or informally) as the primary key
- `primary_key_is_uuid`: this is to help with request validation, so the rest api knows whether to check for uuid validity when handling incomming requests
- `user_owned`: whether or not this object is associated with a user account. if true, this will restrict access to the object to only sessions that have been authenticated as the corresponding user
- `immutable`: setting this to true will make the REST api automatically reject any modifications to the object.
- `disable_all`: when true, prevent the `/all/<object_type>` from returning info for this type
- `disable_rest`: when true, disable all REST endpoints for this object

## uuids and bucket objects
many objects have attributes that are urls to objects in a bucket. i have adopted the convention
of naming the files in the bucket with uuids. i did this to avoid naming collisions and so that i can just make the bucket public,
since the entropy of uuids is so high. given the low stakes nature of the stuff stored in the bucket,
i havent gone to too much trouble to challenge this assumption, but it might be something to keep in mind.

## random notes
- the `stream_url` attribute is deprecated.
- the `user_id` attribute is generally used to determine ownership and permissions for an object.
- the `*_url` and `*_fp` are redundant, it was a bad decision to include both.
- the `desc` attribute on each column def is just there for reference. the whole schema
- is served by the webserver at `localhost:3000/describe` as a handy reference. originally intended
- in lieu of better REST documentation.
- i cannot remember if i was careless enough to write a sql expression that depends on the order
rather than column name, but just in case id recommend against reordering the columns in the schema.
instead just add new ones at the bottom of the array.


## Objects

### user
the user object is hopefully self explanitory. ive included a "desc" attribute for each
of the column definitions in the schema that may be helpful as well. the primary purpose
of having a user object at all is to track purchases and enable a single account accross
multiple devices.

### raw
the raw object is a raw audio file, the thing a user records that will subsequently be
cropped into little pieces. uuid, which is the primary key for the object in the db, will
also be the name of the directory on the bucket where the actual audio file resides, and 
the file itself with be named raw.aac. this is a clumsy holdover from an early arrangment.
if i were to redesign this, id completely flatten the dir structure on the bucket (since
its already like that behind the scenes anyway) and just connect everything with a uuid.

### crop
i use "crop" because it is generic, but everyone calls them "barks". its a single audio
event generally cropped from a raw file. like a single bark plucked from a raw audio file thats
lots of barks and silences. these are the things you are selecting when you are picking
a short, medium and long sound in the app. generated by the `/cloud/to_crops` endpoint

### sequence
this is the musical sequence that is generated by mapping the crops to pitches. it does not
include the backing track in the actual audio, just the mapped crops. generated by the `/cloud/to_sequence` endpoint

### song
the song object is a conglomeration of info need for building the musical sequences
from audio crops. in the bucket, there is a directory with a midi file and 12 backing tracks (one for each key).
there is metadata about the song stored on this object which makes life a little easier for the 
front end and then cloud. these objects get populated in the db with a special script, because
they need to correspond to things in the bucket and it all needs to stay in sync.

### image
this is the (probably) image of a dog face. in addition to storing the basic info about the image,
there are a number of json-like fields for storing settings for how to animate the dog. these
are evaled by the front end so they need to be valid js. this image is what puppet.js uses on the
3d mesh. 

### decoration_image
this is a transparent png that gets overlayed on top of the puppet when sharing the card.
it is optional, and can vary in dimension, depending on whether there is a frame. hence
the `has_frame_dimension` attribute (important for layout on the web front end)

### card_audio
when people want to share a card, 
Tovi generates a mix of the sequence and a backing track, as well as an optional greeting message.
he uploads it to the bucket, and also lets the server know, which will make an entry in this table.

### greeting_card
this was initially conceived of as the single point for all the relevant info for a card that is
going to be shared. it holds most of the information the web front end will need to render a card.
i think the atttributes that are duplicated by card_key are ignored, and the ones on card_key used instead.

### card_key
when the use decides to share a card, there is a little interchange between the client and server
to create one of these. they allow for shorter, prettier urls for sharing. they also allow for different
recipients to receive the same card (i.e. multiple card_keys can point to the same greeting_card)
